mod ff;
mod state;
mod sbox;
mod util;
mod key;
mod aes;

use key::*;
use aes::*;

fn main() {
    encrypt(&[0x00010203, 0x04050607, 0x08090a0b, 0x0c0d0e0f]);
    encrypt(&[0x00010203, 0x04050607, 0x08090a0b, 0x0c0d0e0f, 0x10111213, 0x14151617]);
    encrypt(&[0x00010203, 0x04050607, 0x08090a0b, 0x0c0d0e0f, 0x10111213, 0x14151617, 0x18191a1b, 0x1c1d1e1f]);

    decrypt(&[
        0x00010203, 0x04050607, 0x08090a0b, 0x0c0d0e0f
    ], &[
        0x69, 0xc4, 0xe0, 0xd8, 0x6a, 0x7b, 0x04, 0x30,
        0xd8, 0xcd, 0xb7, 0x80, 0x70, 0xb4, 0xc5, 0x5a
    ]);
    decrypt(&[
        0x00010203, 0x04050607, 0x08090a0b, 0x0c0d0e0f, 0x10111213, 0x14151617
    ], &[
        0xdd, 0xa9, 0x7c, 0xa4, 0x86, 0x4c, 0xdf, 0xe0,
        0x6e, 0xaf, 0x70, 0xa0, 0xec, 0x0d, 0x71, 0x91
    ]);
    decrypt(&[
        0x00010203, 0x04050607, 0x08090a0b, 0x0c0d0e0f, 0x10111213, 0x14151617, 0x18191a1b, 0x1c1d1e1f
    ], &[
        0x8e, 0xa2, 0xb7, 0xca, 0x51, 0x67, 0x45, 0xbf,
        0xea, 0xfc, 0x49, 0x90, 0x4b, 0x49, 0x60, 0x89
    ]);
}

fn encrypt(key: &[u32]) {
    let key = Key::new(key);

    println!("key   {}", key);
    println!("input {}\n", "00112233445566778899aabbccddeeff");

    let encryptor = Encryptor::using(key);

    encryptor.encrypt(&[
        0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99, 0xaa, 0xbb, 0xcc, 0xdd, 0xee, 0xff
    ], true);

    println!("\n");
}

fn decrypt(key: &[u32], input: &[u8]) {
    let key = Key::new(key);

    println!("key   {}", key);
    print!("input ");
    
    for byte in input {
        print!("{:0>2x}", byte);
    }
    print!("\n");    

    let decryptor = Decryptor::using(key);

    decryptor.decrypt(input, true);

    println!("\n");
}